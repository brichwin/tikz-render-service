<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TikZ/PGFPlots Render Service</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
        }

        textarea {
            width: 100%;
            height: 200px;
            font-family: monospace;
            padding: 10px;
            margin-bottom: 10px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin-right: 10px;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .checkbox-container {
            margin: 10px 0;
        }

        .checkbox-container label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .checkbox-container input[type="checkbox"] {
            cursor: pointer;
        }

        #result {
            margin-top: 20px;
            border: 1px solid #ccc;
            padding: 20px;
            min-height: 200px;
            text-align: center;
        }

        #error {
            color: red;
            margin-top: 10px;
        }

        #debug {
            margin-top: 10px;
            padding: 10px;
            background: #f0f0f0;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            text-align: left;
            max-height: 400px;
            overflow-y: auto;
            display: block;
        }

        .loading {
            color: #666;
        }

        .description-section {
            margin-top: 15px;
            padding: 15px;
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: left;
        }

        .description-section h4 {
            margin-top: 0;
            color: #333;
        }

        .alt-text {
            font-family: monospace;
            background: #fff;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            margin: 8px 0;
        }

        details {
            margin-top: 10px;
        }

        summary {
            cursor: pointer;
            font-weight: bold;
            padding: 5px;
            background: #f0f0f0;
            border-radius: 3px;
        }

        details[open] summary {
            margin-bottom: 10px;
        }

        .long-desc-source {
            text-align: left;
            background: #f5f5f5;
            padding: 10px;
            font-size: 12px;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            line-height: 1.6;
        }

        .radio-group {
            margin: 10px 0;
            padding-left: 0px;
        }

        .radio-group label {
            display: inline-block;
            margin-right: 15px;
            cursor: pointer;
        }

        .radio-group input[type="radio"] {
            cursor: pointer;
            margin-right: 5px;
        }
    </style>
    <script class="show">
        MathJax = {
            tex: { inlineMath: { '[+]': [['$', '$']] } },
            options: {
                menuOptions: {
                    settings: {
                        enrich: false,         // true to enable semantic-enrichment
                        collapsible: false,   // true to enable collapsible math
                        speech: true,         // true to enable speech generation
                        braille: true,        // true to enable Braille generation
                        assistiveMml: true,  // true to enable assistive MathML
                    }
                }
            },
            startup: {
                ready: () => {
                    MathJax.startup.defaultReady();
                    MathJax.startup.promise.then(() => {
                        window.initEnhancedZoomExpressionDialog();
                    });
                }
            }
        };
    </script>
    <script class="show" defer src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14/dist/markdown-it.min.js"></script>
</head>

<body>
    <h1>TikZ/PGFPlots Render Service</h1>

    <h2>Input</h2>
    <div><label for="tikzInput">Enter your TikZ code here:</label></div>

    <textarea id="tikzInput">\begin{tikzpicture}
  % Draw axes
  \draw[->] (-0.5,0) -- (4.5,0) node[right] {$x$};
  \draw[->] (0,-2.5) -- (0,2.5) node[above] {$y$};
  
  % X-axis tick marks and labels
  \foreach \x in {0,1,2,3,4}
    \draw (\x,0.1) -- (\x,-0.1) node[below] {\x};
  
  % Y-axis tick marks and labels
  \foreach \y in {-2,-1,0,1,2}
    \draw (0.1,\y) -- (-0.1,\y) node[left] {\y};
  
  % Draw a sine wave
  \draw[blue, thick, domain=0:4, samples=100] plot (\x, {2*sin(\x r)});
  
  % Add labels
  \node at (2, -2) {Sample TikZ Diagram};
\end{tikzpicture}</textarea>

    <div style="margin-bottom: 15px;">
        <label for="exampleSelect"><strong>Load Example:</strong></label>
        <select id="exampleSelect" style="margin-left: 10px; padding: 5px; font-size: 14px;">
            <!-- Options populated by JavaScript -->
        </select>
        <button type="button" onclick="loadExample()" style="margin-left: 10px; padding: 5px 15px;">Load
            Example</button>
    </div>

    <h2>AI Description Options</h2>
    <div class="checkbox-container">
        <label>
            <input type="checkbox" id="generateDescriptions" checked>
            Generate AI accessibility descriptions (requires API key and PNG rendering)
        </label>
    </div>


    <div style="margin-bottom: 15px;">
        <label for="customInstructions"><strong>Additional instructions for AI (optional):</strong></label>
        <textarea id="customInstructions" 
                  placeholder="Example: Focus on formative learning objectives, or emphasize assessment criteria, or describe for a specific audience..."
                  style="width: 100%; height: 80px; font-family: Arial, sans-serif; padding: 8px; margin-top: 5px; box-sizing: border-box; resize: vertical;"></textarea>
        <small style="color: #666;">These instructions will be included in the AI prompt to guide description generation.</small>
    </div>

    <h2>Render Options</h2>
    <div>
        <button type="button" id="svgButton" onclick="render('svg')">Render as SVG</button>
        <button type="button" id="pngButton" onclick="render('png')">Render as PNG</button>
        <button type="button" id="downloadButton" onclick="downloadImage()" disabled>Download Image</button>
        <button type="button" id="toggleDebugButton" onclick="toggleDebug()">Hide Debug Info</button>
    </div>

    <div class="radio-group" id="formatOptions">
        <fieldset>
            <legend>Long description format:</legend>
            <label>
                <input type="radio" name="outputFormat" value="html" checked>
                HTML
            </label>
            <label>
                <input type="radio" name="outputFormat" value="md">
                Markdown
            </label>
        </fieldset>
    </div>

    <h2 id="debugInformation" style="display: none;">Debug Information</h2>
    <div id="error"></div>
    <div id="debug"></div>

    <h2>Result</h2>
    <div id="result"></div>

    <script>
        // TikZ Examples Data Structure
        const tikzExamples = [
            {
                title: "Sine Wave (Default)",
                code: `\\begin{tikzpicture}
  % Draw axes
  \\draw[->] (-0.5,0) -- (4.5,0) node[right] {$x$};
  \\draw[->] (0,-2.5) -- (0,2.5) node[above] {$y$};
  
  % X-axis tick marks and labels
  \\foreach \\x in {0,1,2,3,4}
    \\draw (\\x,0.1) -- (\\x,-0.1) node[below] {\\x};
  
  % Y-axis tick marks and labels
  \\foreach \\y in {-2,-1,0,1,2}
    \\draw (0.1,\\y) -- (-0.1,\\y) node[left] {\\y};
  
  % Draw a sine wave
  \\draw[blue, thick, domain=0:4, samples=100] plot (\\x, {2*sin(\\x r)});
  
  % Add labels
  \\node at (2, -2) {Sample TikZ Diagram};
\\end{tikzpicture}`
            },
            {
                title: "Physics Example - Signpost",
                code: `\\tikzstyle{load}   = [ultra thick,-latex]
\\tikzstyle{stress} = [-latex]
\\tikzstyle{dim}    = [latex-latex]
\\tikzstyle{axis}   = [-latex,black!55]

% Drawing Views
\\tikzstyle{isometric}=[x={(0.710cm,-0.410cm)},y={(0cm,0.820cm)},z={(-0.710cm,-0.410cm)}]
\\tikzstyle{dimetric} =[x={(0.935cm,-0.118cm)},y={(0cm,0.943cm)},z={(-0.354cm,-0.312cm)}]
\\tikzstyle{dimetric2}=[x={(0.935cm,-0.118cm)},z={(0cm,0.943cm)},y={(+0.354cm,+0.312cm)}]
\\tikzstyle{trimetric}=[x={(0.926cm,-0.207cm)},y={(0cm,0.837cm)},z={(-0.378cm,-0.507cm)}]

  \\begin{tikzpicture}
    \\node (origin) at (0,0) {}; % shift relative baseline
    \\coordinate (O) at (2,3);
    \\draw[fill=gray!10] (O) circle (1);
    \\draw[fill=white] (O) circle (0.75) node[below,yshift=-1.125cm] {Signpost Cross Section};
    \\draw[dim] (O) ++(-0.75,0) -- ++(1.5,0) node[midway,above] {$d_i$};
    \\draw[dim] (O) ++(-1,1.25) -- ++(2,0) node[midway,above] {$d_o$}; 
    \\foreach \\x in {-1,1} {
      \\draw (O) ++(\\x,0.25) -- ++(0,1.25);
    }
  \\end{tikzpicture}%
  \\begin{tikzpicture}[dimetric2]
        \\coordinate (O) at (0,0,0);
        \\draw[axis] (O) -- ++(6,0,0) node[right] {$x$};
        \\draw[axis] (O) -- ++(0,6,0) node[above right] {$y$};
        \\draw[axis] (O) -- ++(0,0,6) node[above] {$z$};
        \\draw[fill=gray!50] (0,0,-0.5) circle (0.5); 
        \\fill[fill=gray!50] (-0.46,-0.2,-0.5) -- (0.46,0.2,-0.5) -- (0.46,0.2,0) -- (-0.46,-0.2,0) -- cycle;
        \\draw[fill=gray!20] (O) circle (0.5);
    \\draw (0.46,0.2,-0.5) -- ++(0,0,0.5) node[below right,pos=0.0] {Fixed Support};
    \\draw (-0.46,-0.2,-0.5) -- ++(0,0,0.5);
    \\draw[fill=gray!10] (O) circle (0.2);
    \\fill[fill=gray!10] (-0.175,-0.1,0) -- (0.175,0.1,0) -- ++(0,0,4) -- (-0.175,-0.1,4) -- cycle;
    \\draw (-0.175,-0.1,0) -- ++(0,0,4);
    \\draw (0.175,0.1,0) -- ++(0,0,4) node[right,midway] {Steel Post};
    \\draw (4,0,3.95) -- ++(0,0,-1);
    \\foreach \\z in {0.5,0.75,...,5} {
      \\draw[-latex] (-2*\\z/5-0.2,0,\\z) -- (-0.2,0,\\z);
    }
    \\draw[load] (0,0,4) -- ++(0,0,-1.25) node[right,xshift=0.1cm] {$F_{z1}$};
    \\draw[fill=gray!20] (-0.25,-0.25,5) -- (4,-0.25,5) -- (4,+0.25,5) -- (-0.25,+0.25,5) -- cycle; 
    \\draw[fill=gray!50] (+4.00,-0.25,4) -- (4,+0.25,4) -- (4,+0.25,5) -- (+4.00,-0.25,5) -- cycle; 
    \\draw[fill=gray!10] (-0.25,-0.25,4) -- (4,-0.25,4) -- (4,-0.25,5) -- (-0.25,-0.25,5) -- cycle; 
    \\draw (4.05,0,4) -- ++(1,0,0);
    \\draw (4.05,0,5) -- ++(1,0,0);
    \\draw[dim] (4.5,0,0) -- ++(0,0,4) node[midway,right] {$h_1$};
    \\draw[dim] (4.5,0,4) -- ++(0,0,1) node[midway,right] {$h_2$};
    \\draw[dim] (0,0,3.4) -- ++(4,0,0) node[midway,below] {$b_2$};
    \\coordinate (P) at (2,-0.25,4.5);
    \\draw (P) -- ++(0,0,0.25);
    \\draw (P) -- ++(0.25,0,0);
    \\draw[dim] (2.125,-0.25,4.5) -- ++(0,0,-0.5) node[midway,right] {$z_1$};
    \\draw[dim] (2,-0.25,4.625) -- ++(-2,0,0) node[midway,below] {$x_1$};
    \\draw[load] (2,-2.45,4.5) -- ++(0,2.2,0) node[pos=0.0,right,xshift=0.08cm] {$F_{y1}$};
    \\draw[axis,dashed,-] (O) -- (0,0,5);
    \\draw (0,0,5.5) -- ++(4,0,0) node[midway,above] {$w_{z}$};
    \\foreach \\x in {0,0.25,...,4} {
      \\draw[-latex] (\\x,0,5.5) -- ++(0,0,-0.5);
    }
    \\draw (-0.2,0,0) -- ++(-2,0,5) node[above,xshift=0.5cm] {$w_{x}=\\frac{z}{h_1+h_2} w_0$};
  \\end{tikzpicture}`
            },
            {
                title: "Planets by Gerard Fleuter",
                code: `\\tikzset{partial ellipse/.style args =
  {#1:#2:#3}{insert path={+ (#1:#3) arc (#1:#2:#3)}}}
\\begin{tikzpicture}[>=latex]
  %  ellipses
  \\draw [fill=white!90!red]    (3,-1.8) ellipse    (4cm and 1 cm);
  \\draw [fill=yellow!90!green] (3,-1.8) ellipse (3cm and 0.75 cm);
  \\draw [fill=white!90!green]  (3,-1.8) ellipse  (2cm and 0.5 cm);

  % -- Soleil
  \\shade [ball color=gray!10!yellow] (3,-1.8) circle (1);
  \\node (soleil) at (3,-1.8) {\\bf Soleil};
  % partial ellipse pour tracé devant le Soleil
  \\draw (3,-1.8) [partial ellipse=220:320:2cm and 0.5cm]
        (3,-1.8) [partial ellipse=220:320:3cm and 0.75cm];

  % Venus
  \\shade [ball color=gray!10!orange] (1.6,-1.8) circle (.2);
  \\node (venus) at (1.5,-1.45) {Venus}; 

  % ombre de Venus
  \\draw[color=white!70!black,fill=white!70!black]
    (1.6,-2.3) ellipse (2mm and 0.5mm);

  % Mercure
  \\shade [ball color=gray!10!orange] (5,-1.225) circle (.25);
  \\node (mercure) at (5,-0.8) {Mercure}; 

  % Earth
  \\shade [ball color=white!50!blue] (5.75,-2.5) circle (.33);
  \\node (terre) at (6.6,-2.6) {\\bf Terre};

  % Lune
  \\shade [ball color=yellow] (5.25,-2.8) circle (.1);
  \\node (lune) at (5.25,-3) {Lune};
     
  % Mars
  \\draw (3,-1.8) [partial ellipse=45:120:9cm and 2.5cm];
  \\shade [ball color=black!50!red] (5,0.66) circle (.15);
  \\node (mars) at (5,1) {\\bf Mars};   
  % trajet
  \\draw [line width=2pt,blue,->,>=latex] (terre) to[out=0,in=0] (mars);   
\\end{tikzpicture}`
            },
            {
                title: "Bar Chart",
                code: `\\begin{tikzpicture}
  \\draw[->] (0,0) -- (5,0) node[right] {Category};
  \\draw[->] (0,0) -- (0,4) node[above] {Value};
  
  \\draw[fill=blue!50] (0.5,0) rectangle (1,2);
  \\draw[fill=red!50] (1.5,0) rectangle (2,3);
  \\draw[fill=green!50] (2.5,0) rectangle (3,1.5);
  \\draw[fill=yellow!50] (3.5,0) rectangle (4,3.5);
  
  \\node at (0.75,-0.3) {A};
  \\node at (1.75,-0.3) {B};
  \\node at (2.75,-0.3) {C};
  \\node at (3.75,-0.3) {D};
\\end{tikzpicture}`
            },
            {
                title: "Linear Function with Annotations - Henri Menke",
                code: `\\usetikzlibrary{arrows,intersections}
\\begin{tikzpicture}[
    thick,
    >=stealth',
    dot/.style = {
      draw,
      fill = white,
      circle,
      inner sep = 0pt,
      minimum size = 4pt
    }
  ]
  \\coordinate (O) at (0,0);
  \\draw[->] (-0.3,0) -- (8,0) coordinate[label = {below:$x$}] (xmax);
  \\draw[->] (0,-0.3) -- (0,5) coordinate[label = {right:$f(x)$}] (ymax);
  \\path[name path=x] (0.3,0.5) -- (6.7,4.7);
  \\path[name path=y] plot[smooth] coordinates {(-0.3,2) (2,1.5) (4,2.8) (6,5)};
  \\scope[name intersections = {of = x and y, name = i}]
    \\fill[gray!20] (i-1) -- (i-2 |- i-1) -- (i-2) -- cycle;
    \\draw      (0.3,0.5) -- (6.7,4.7) node[pos=0.8, below right] {Secant};
    \\draw[red] plot[smooth] coordinates {(-0.3,2) (2,1.5) (4,2.8) (6,5)};
    \\draw (i-1) node[dot, label = {above:$P$}] (i-1) {} -- node[left]
      {$f(x_0)$} (i-1 |- O) node[dot, label = {below:$x_0$}] {};
    \\path (i-2) node[dot, label = {above:$Q$}] (i-2) {} -- (i-2 |- i-1)
      node[dot] (i-12) {};
    \\draw           (i-12) -- (i-12 |- O) node[dot,
                              label = {below:$x_0 + \\varepsilon$}] {};
    \\draw[blue, <->] (i-2) -- node[right] {$f(x_0 + \\varepsilon) - f(x_0)$}
                              (i-12);
    \\draw[blue, <->] (i-1) -- node[below] {$\\varepsilon$} (i-12);
    \\path       (i-1 |- O) -- node[below] {$\\varepsilon$} (i-2 |- O);
    \\draw[gray]      (i-2) -- (i-2 -| xmax);
    \\draw[gray, <->] ([xshift = -0.5cm]i-2 -| xmax) -- node[fill = white]
      {$f(x_0 + \\varepsilon)$}  ([xshift = -0.5cm]xmax);
  \\endscope
\\end{tikzpicture}`
            },
            {
                title: "Polar Plot - Alex Chan",
                code: `\\begin{tikzpicture}[>=latex]

% Draw the lines at multiples of pi/12
\\foreach \\ang in {0,...,31} {
  \\draw [lightgray] (0,0) -- (\\ang * 180 / 16:4);
}

% Concentric circles and radius labels
\\foreach \\s in {0, 1, 2, 3} {
  \\draw [lightgray] (0,0) circle (\\s + 0.5);
  \\draw (0,0) circle (\\s);
  \\node [fill=white] at (\\s, 0) [below] {\\scriptsize $\\s$};
}

% Add the labels at multiples of pi/4
\\foreach \\ang/\\lab/\\dir in {
  0/0/right,
  1/{\\pi/4}/{above right},
  2/{\\pi/2}/above,
  3/{3\\pi/4}/{above left},
  4/{\\pi}/left,
  5/{5\\pi/4}/{below left},
  7/{7\\pi/4}/{below right},
  6/{3\\pi/2}/below} {
  \\draw (0,0) -- (\\ang * 180 / 4:4.1);
  \\node [fill=white] at (\\ang * 180 / 4:4.2) [\\dir] {\\scriptsize $\\lab$};
}

% The double-lined circle around the whole diagram
\\draw [style=double] (0,0) circle (4);

\\fill [fill=red!50!black, opacity=0.5] plot [domain=-pi/2:pi/2]
  (xy polar cs:angle=\\x r, radius= {2-2*sin(\\x r)});
\\draw [thick, color=red, domain=0:2*pi, samples=200, smooth]
  plot (xy polar cs:angle=\\x r, radius={2-2*sin(\\x r)});
\\node [fill=white] at (2,1) {$r=2-2\\sin\\theta$};

\\end{tikzpicture} `
            },
            {
                title: "5 Venn Diagrams",
                code: `% Definition of circles
\\def\\firstcircle{(0,0) circle (1.5cm)}
\\def\\secondcircle{(0:2cm) circle (1.5cm)}

\\colorlet{circle edge}{blue!50}
\\colorlet{circle area}{blue!20}

\\tikzset{filled/.style={fill=circle area, draw=circle edge, thick},
    outline/.style={draw=circle edge, thick}}

\\setlength{\\parskip}{5mm}
% Set A and B
\\begin{tikzpicture}
    \\begin{scope}
        \\clip \\firstcircle;
        \\fill[filled] \\secondcircle;
    \\end{scope}
    \\draw[outline] \\firstcircle node {$A$};
    \\draw[outline] \\secondcircle node {$B$};
    \\node[anchor=south] at (current bounding box.north) {$A \\cap B$};
\\end{tikzpicture}

%Set A or B but not (A and B) also known a A xor B
\\begin{tikzpicture}
    \\draw[filled, even odd rule] \\firstcircle node {$A$}
                                 \\secondcircle node{$B$};
    \\node[anchor=south] at (current bounding box.north) {$\\overline{A \\cap B}$};
\\end{tikzpicture}

% Set A or B
\\begin{tikzpicture}
    \\draw[filled] \\firstcircle node {$A$}
                  \\secondcircle node {$B$};
    \\node[anchor=south] at (current bounding box.north) {$A \\cup B$};
\\end{tikzpicture}

% Set A but not B
\\begin{tikzpicture}
    \\begin{scope}
        \\clip \\firstcircle;
        \\draw[filled, even odd rule] \\firstcircle node {$A$}
                                     \\secondcircle;
    \\end{scope}
    \\draw[outline] \\firstcircle
                   \\secondcircle node {$B$};
    \\node[anchor=south] at (current bounding box.north) {$A - B$};
\\end{tikzpicture}

% Set B but not A
\\begin{tikzpicture}
    \\begin{scope}
        \\clip \\secondcircle;
        \\draw[filled, even odd rule] \\firstcircle
                                     \\secondcircle node {$B$};
    \\end{scope}
    \\draw[outline] \\firstcircle node {$A$}
                   \\secondcircle;
    \\node[anchor=south] at (current bounding box.north) {$B - A$};
\\end{tikzpicture}`}, {
    title: 'Limit with discontinuity',
    code: `\\pgfplotsset{compat=1.18}
\\begin{tikzpicture}
  \\begin{axis}[
    width=10cm, height=6cm,
    domain=-0.5:0.5,
    samples=201,
    axis lines=middle,
    xmax=0.52, xmin=-0.52,
    ymin=0.6, ymax=1.2,
    xlabel={$x$},
    ylabel={$f(x)$},
    xlabel style={at={(axis description cs:0.98,0.1)},anchor=north east},
    ylabel style={at={(axis description cs:0.02,0.98)},anchor=north west},
    xtick={-0.5,-0.25,0,0.25,0.5},
    ytick={0.6,0.8,1.0},
    grid=both,
    grid style={dashed,gray!30},
    every axis plot/.append style={thick}
  ]
    % plot sin(x)/x (use sin(deg(x)) because PGF trig expects degrees)
    \\addplot[domain=-0.5:-0.0005,blue] {sin(deg(x))/x};
    \\addplot[domain=0.0005:0.5,blue]  {sin(deg(x))/x};

    % horizontal line y = 1 (limit)
    \\addplot[dashed, darkgray] {1};

    % open circle to indicate removable discontinuity at x=0
    \\node[draw=black, fill=white, circle, inner sep=1.6pt] at (axis cs:0,1) {};

    % small annotation
    \\node[anchor=west, font=\\footnotesize] at (axis cs:0.02,1.04) {limit $1$ as $x\\to0$};

  \\end{axis}
\\end{tikzpicture}
`}
        ];

        const API_URL = 'http://localhost:3010/api/render';
        const DESCRIBE_URL = 'http://localhost:3010/api/describe';
        let isRendering = false;
        let currentImageUrl = null;
        let currentFormat = null;
        let md = null; // markdown-it instance

        // Initialize markdown-it when available
        if (typeof markdownit !== 'undefined') {
            md = markdownit({
                html: true,
                breaks: true,
                typographer: true
            });
        }

        // Detect unexpected page reloads
        window.addEventListener('beforeunload', function (e) {
            if (isRendering) {
                console.error('WARNING: Page is reloading during render!');
                const message = 'Rendering in progress. Are you sure you want to leave?';
                e.returnValue = message;
                return message;
            }
        });

        function log(message) {
            const debugDiv = document.getElementById('debug');
            const timestamp = new Date().toISOString();
            const logMessage = timestamp + ': ' + message + '\n';
            debugDiv.textContent += logMessage;
            // Auto-scroll to bottom to show latest log entry
            debugDiv.scrollTop = debugDiv.scrollHeight;
            console.log(timestamp, message);
        }

        function toggleDebug() {
            const debugDiv = document.getElementById('debug');
            const toggleButton = document.getElementById('toggleDebugButton');
            const debugHeading = document.getElementById('debugInformation');
            
            if (debugDiv.style.display === 'none') {
                debugDiv.style.display = 'block';
                debugHeading.style.display = 'block';
                toggleButton.textContent = 'Hide Debug Info';
                log('Debug info shown');
            } else {
                debugDiv.style.display = 'none';
                debugHeading.style.display = 'none';
                toggleButton.textContent = 'Show Debug Info';
                log('Debug info hidden');
            }
        }

        function setButtonsEnabled(enabled) {
            document.getElementById('svgButton').disabled = !enabled;
            document.getElementById('pngButton').disabled = !enabled;
            // Download button state is managed separately
        }

        function setDownloadButtonEnabled(enabled) {
            document.getElementById('downloadButton').disabled = !enabled;
        }

        function downloadImage() {
            if (!currentImageUrl || !currentFormat) {
                log('No image available for download');
                return;
            }

            log('Downloading image as graphic.' + currentFormat);
            
            // Create a temporary anchor element for download
            const link = document.createElement('a');
            link.href = currentImageUrl;
            link.download = 'graphic.' + currentFormat;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            log('Download initiated');
        }

        async function render(format) {
            // Prevent multiple simultaneous renders
            if (isRendering) {
                log('Already rendering, please wait...');
                return false;
            }

            isRendering = true;
            setButtonsEnabled(false);
            setDownloadButtonEnabled(false);

            // Clear previous image data
            if (currentImageUrl) {
                URL.revokeObjectURL(currentImageUrl);
                currentImageUrl = null;
                currentFormat = null;
            }

            const renderStartTime = Date.now();

            log('=== RENDER STARTED ===');
            log('Render function called with format: ' + format);

            const tikzCode = document.getElementById('tikzInput').value;
            const generateDesc = document.getElementById('generateDescriptions').checked;
            const resultDiv = document.getElementById('result');
            const errorDiv = document.getElementById('error');
            const debugDiv = document.getElementById('debug');
            const debugHeading = document.getElementById('debugInformation');

            // Clear previous results
            resultDiv.innerHTML = '<p class="loading">Rendering... Please wait, this may take up to 30 seconds for complex diagrams.</p>';
            errorDiv.textContent = '';
            
            // Don't change debug visibility - respect current state
            // Debug visibility is controlled only by the toggle button

            log('Format: ' + format);
            log('Generate descriptions: ' + generateDesc);
            log('TikZ code length: ' + tikzCode.length + ' characters');
            log('First 100 chars: ' + tikzCode.substring(0, 100));

            try {
                log('Making fetch request to: ' + API_URL);
                log('Current timestamp: ' + Date.now());

                const startTime = Date.now();

                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        tikzCode: tikzCode,
                        format: format
                    })
                }).catch(err => {
                    log('FETCH FAILED: ' + err.name + ' - ' + err.message);
                    throw err;
                });

                const elapsed = Date.now() - startTime;
                log('Response received after ' + elapsed + 'ms');
                log('Response status: ' + response.status + ' ' + response.statusText);
                log('Response headers:');
                response.headers.forEach((value, key) => {
                    log('  ' + key + ': ' + value);
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    log('Error response body: ' + errorText);
                    let errorMessage;
                    try {
                        const error = JSON.parse(errorText);
                        errorMessage = error.error || 'Rendering failed';
                        if (error.details) {
                            errorMessage += ' - ' + error.details;
                        }
                    } catch (e) {
                        errorMessage = errorText || 'Rendering failed';
                    }
                    throw new Error(errorMessage);
                }

                log('Converting response to blob...');
                const blob = await response.blob();
                log('Blob created - size: ' + blob.size + ' bytes, type: ' + blob.type);

                if (blob.size === 0) {
                    throw new Error('Received empty response from server');
                }

                log('Creating object URL...');
                const imageUrl = URL.createObjectURL(blob);
                log('Object URL created: ' + imageUrl);

                // Store for download functionality
                currentImageUrl = imageUrl;
                currentFormat = format;
                setDownloadButtonEnabled(true);

                const cacheStatus = response.headers.get('X-Cache');
                const cacheNote = cacheStatus === 'HIT' ? ' (from cache)' : ' (freshly rendered)';

                // Time checkpoint: TikZ rendering and image display complete
                const tikzRenderTime = Date.now() - renderStartTime;
                log('*** TikZ RENDER & IMAGE DISPLAY TIME: ' + tikzRenderTime + 'ms (' + (tikzRenderTime / 1000).toFixed(2) + ' seconds) ***');

                // Display image immediately with placeholder alt text
                log('Displaying image immediately...');
                const placeholderAltText = 'Rendered TikZ diagram';

                if (format === 'svg') {
                    const text = await blob.text();
                    log('SVG text length: ' + text.length + ' characters');
                    resultDiv.innerHTML = `
                        <p>Result${cacheNote}:</p>
                        <img src="${imageUrl}" alt="${escapeHtml(placeholderAltText)}" style="max-width: 100%; border: 1px solid #ddd;" onload="console.log('Image loaded successfully')">
                        ${generateDesc ? '<div id="ai-descriptions-placeholder" class="description-section"><p><em>Generating AI accessibility descriptions...</em></p></div>' : ''}
                        <details style="margin-top: 10px;">
                            <summary>View SVG source</summary>
                            <pre style="text-align: left; overflow-x: auto; background: #f5f5f5; padding: 10px;">${escapeHtml(text)}</pre>
                        </details>
                    `;
                } else {
                    resultDiv.innerHTML = `
                        <p>Result${cacheNote}:</p>
                        <img src="${imageUrl}" alt="${escapeHtml(placeholderAltText)}" style="max-width: 100%; border: 1px solid #ddd;" onload="console.log('Image loaded successfully')">
                        ${generateDesc ? '<div id="ai-descriptions-placeholder" class="description-section"><p><em>Generating AI accessibility descriptions...</em></p></div>' : ''}
                    `;
                }

                log('Image displayed successfully!');
                log('Download button enabled - ready to download as graphic.' + format);

                // Generate AI descriptions asynchronously if enabled
                if (generateDesc) {
                    log('Starting AI description generation in background...');
                    const aiDescStartTime = Date.now();
                    
                    // Generate descriptions asynchronously
                    generateDescriptions(blob, format, tikzCode).then(descriptions => {
                        const aiDescTime = Date.now() - aiDescStartTime;
                        log('*** AI DESCRIPTION GENERATION TIME: ' + aiDescTime + 'ms (' + (aiDescTime / 1000).toFixed(2) + ' seconds) ***');
                        
                        // Update the placeholder with actual descriptions
                        const placeholder = document.getElementById('ai-descriptions-placeholder');
                        if (placeholder && descriptions) {
                            // Render long description based on format
                            let longDescHtml;
                            if (descriptions.outputFormat === 'md' && md) {
                                log('Rendering Markdown description with markdown-it');
                                
                                // Convert LaTeX delimiters to use $ instead of \( \) before markdown processing
                                // This prevents markdown-it from escaping the backslashes
                                let mdText = descriptions.longDescription;
                                mdText = mdText.replace(/\\\(/g, '$');
                                mdText = mdText.replace(/\\\)/g, '$');
                                mdText = mdText.replace(/\\\[/g, '$$');
                                mdText = mdText.replace(/\\\]/g, '$$');
                                
                                longDescHtml = md.render(mdText);
                                
                                log('Converted LaTeX delimiters and rendered Markdown');
                            } else {
                                longDescHtml = descriptions.longDescription;
                            }

                            placeholder.innerHTML = `
                                <h4>AI-Generated Accessibility Descriptions</h4>
                                <p><strong>Output Format:</strong> ${descriptions.outputFormat.toUpperCase()}</p>
                                <p><strong>Alt Text (for screen readers):</strong></p>
                                <div class="alt-text">${escapeHtml(descriptions.altText)}</div>
                                <details>
                                    <summary>Long Description</summary>
                                    <div style="padding: 10px;">${longDescHtml}</div>
                                </details>
                                <details>
                                    <summary>View Long Description Source</summary>
                                    <pre class="long-desc-source">${escapeHtml(descriptions.longDescription)}</pre>
                                </details>
                            `;
                            
                            // Update the image alt text
                            const img = resultDiv.querySelector('img');
                            if (img) {
                                img.alt = descriptions.altText;
                            }
                            
                            // Typeset math in the newly inserted content
                            if (window.MathJax) {
                                log('Typesetting math with MathJax...');
                                MathJax.typesetPromise([placeholder]).then(() => {
                                    log('MathJax typesetting complete');
                                }).catch((err) => {
                                    log('MathJax error: ' + err.message);
                                });
                            }
                        } else if (placeholder) {
                            placeholder.innerHTML = '<p><em>Failed to generate AI descriptions. See debug log for details.</em></p>';
                        }
                    }).catch(error => {
                        log('AI description generation failed: ' + error.message);
                        const placeholder = document.getElementById('ai-descriptions-placeholder');
                        if (placeholder) {
                            placeholder.innerHTML = '<p><em>Failed to generate AI descriptions. See debug log for details.</em></p>';
                        }
                    });
                }

                log('=== RENDER COMPLETED SUCCESSFULLY ===');

            } catch (error) {
                log('!!! ERROR OCCURRED !!!');
                log('Error type: ' + error.name);
                log('Error message: ' + error.message);
                if (error.stack) {
                    log('Stack trace: ' + error.stack);
                }
                resultDiv.innerHTML = '<p style="color: red;">Rendering failed. See debug info below.</p>';
                errorDiv.textContent = 'Error: ' + error.message;
                log('=== RENDER FAILED ===');
            } finally {
                isRendering = false;
                setButtonsEnabled(true);

                const totalElapsed = Date.now() - renderStartTime;
                log('Buttons re-enabled, ready for next render');
                log('*** TOTAL TIME (TikZ Render + Display): ' + totalElapsed + 'ms (' + (totalElapsed / 1000).toFixed(2) + ' seconds) ***');
                log('==============================================');
            }

            return false;
        }

        async function generateDescriptions(blob, format, tikzCode) {
            log('Generating AI descriptions...');

            try {
                log('Converting blob to base64 for description generation...');
                const imageBase64 = await blobToBase64(blob);
                
                // Get selected output format
                const outputFormat = document.querySelector('input[name="outputFormat"]:checked').value;
                log('Requested output format: ' + outputFormat);
                
                // Get custom instructions
                const customInstructions = document.getElementById('customInstructions').value.trim();
                if (customInstructions) {
                    log('Custom instructions provided: ' + customInstructions.substring(0, 100) + (customInstructions.length > 100 ? '...' : ''));
                }
                
                const requestBody = {
                    tikzCode: tikzCode,
                    imageBase64: imageBase64,
                    format: format,
                    outputFormat: outputFormat
                };

                // Add custom instructions if provided
                if (customInstructions) {
                    requestBody.customInstructions = customInstructions;
                }
                
                const response = await fetch(DESCRIBE_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Description generation failed');
                }

                // Parse plain text response
                const text = await response.text();

                // Split on the first blank line only
                const firstBlankLineMatch = text.match(/\n\s*\n/);

                if (!firstBlankLineMatch) {
                    throw new Error('Invalid description format received from server');
                }

                const splitIndex = firstBlankLineMatch.index + firstBlankLineMatch[0].length;

                const descriptions = {
                    altText: text.substring(0, firstBlankLineMatch.index).trim(),
                    longDescription: text.substring(splitIndex).trim(),
                    outputFormat: outputFormat
                };

                // Check cache status from header
                const cacheStatus = response.headers.get('X-Cache');
                if (cacheStatus === 'HIT') {
                    log('AI descriptions retrieved from cache');
                } else {
                    log('AI descriptions freshly generated');
                }

                log('AI descriptions generated successfully');
                log('Alt text: ' + descriptions.altText);

                return descriptions;
            } catch (error) {
                log('Description generation failed: ' + error.message);
                throw error;
            }
        }

        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    // Remove the data URL prefix (e.g., "data:image/svg+xml;base64,")
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatHtmlSource(html) {
            // Add newlines and basic indentation to HTML for readability
            let formatted = html;

            // Add newlines after opening tags (except inline elements)
            formatted = formatted.replace(/(<(?:p|div|ul|ol|li|table|tr|td|th|details|summary)[^>]*>)/gi, '$1\n  ');

            // Add newlines before closing tags
            formatted = formatted.replace(/(<\/(?:p|div|ul|ol|li|table|tr|td|th|details|summary)>)/gi, '\n$1\n');

            // Clean up multiple newlines
            formatted = formatted.replace(/\n\s*\n\s*\n/g, '\n\n');

            // Trim
            formatted = formatted.trim();

            return formatted;
        }

        function populateExamplesDropdown() {
            const select = document.getElementById('exampleSelect');
            tikzExamples.forEach((example, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = example.title;
                select.appendChild(option);
            });
        }

        function loadExample() {
            const select = document.getElementById('exampleSelect');
            const selectedIndex = select.value;
            const example = tikzExamples[selectedIndex];

            if (example) {
                document.getElementById('tikzInput').value = example.code;
                log('Loaded example: ' + example.title);
            }
        }

        // Test connection on page load
        window.addEventListener('load', async () => {
            log('Page loaded at: ' + new Date().toISOString());
            log('User agent: ' + navigator.userAgent);

            // Check if markdown-it loaded
            if (md) {
                log('✓ markdown-it library loaded successfully');
            } else {
                log('⚠ markdown-it library not available - Markdown rendering disabled');
            }

            // Populate examples dropdown
            populateExamplesDropdown();

            // Ensure download button starts disabled
            setDownloadButtonEnabled(false);

            // Set initial debug button text and heading visibility based on initial visibility
            const debugDiv = document.getElementById('debug');
            const toggleButton = document.getElementById('toggleDebugButton');
            const debugHeading = document.getElementById('debugInformation');
            
            const isDebugVisible = debugDiv.style.display !== 'none';
            toggleButton.textContent = isDebugVisible ? 'Hide Debug Info' : 'Show Debug Info';
            debugHeading.style.display = isDebugVisible ? 'block' : 'none';

            try {
                log('Testing connection to server...');
                const response = await fetch('http://localhost:3010/api/health');
                if (response.ok) {
                    const data = await response.json();
                    log('✓ Server is healthy: ' + JSON.stringify(data));
                    if (data.aiDescriptions) {
                        log('✓ AI descriptions enabled');
                    } else {
                        log('⚠ AI descriptions disabled (no API key)');
                    }
                } else {
                    log('✗ Server returned error: ' + response.status);
                }
            } catch (error) {
                log('✗ Cannot connect to server: ' + error.message);
                log('Make sure the server is running on port 3010');
            }
        });

        // Log if page visibility changes
        document.addEventListener('visibilitychange', () => {
            log('Page visibility changed: ' + document.visibilityState);
        });

        console.log('TikZ Demo page initialized');
    </script></body>

</html>